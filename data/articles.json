[
  {
    "id": "1",
    "title": "Vue 3 Composition API 深度解析",
    "slug": "vue3-composition-api-deep-dive",
    "excerpt": "深入探讨 Vue 3 Composition API 的设计理念、核心特性和最佳实践，帮助开发者更好地理解和使用这一强大的新特性。",
    "content": "# Vue 3 Composition API 深度解析\n\nVue 3 引入的 Composition API 是一个革命性的变化，它为我们提供了更灵活、更强大的组件逻辑组织方式。\n\n## 什么是 Composition API\n\nComposition API 是 Vue 3 中新增的一套 API，它允许我们使用函数的方式来组织组件的逻辑。与传统的 Options API 相比，Composition API 提供了更好的逻辑复用、类型推导和代码组织能力。\n\n## 核心概念\n\n### setup 函数\n\n`setup` 函数是 Composition API 的入口点：\n\n```javascript\nimport { ref, reactive } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    const state = reactive({ name: 'Vue 3' })\n    \n    function increment() {\n      count.value++\n    }\n    \n    return {\n      count,\n      state,\n      increment\n    }\n  }\n}\n```\n\n### 响应式 API\n\nVue 3 提供了多种响应式 API：\n\n- `ref()`: 创建响应式引用\n- `reactive()`: 创建响应式对象\n- `computed()`: 创建计算属性\n- `watch()`: 监听响应式数据变化\n\n## 最佳实践\n\n1. **逻辑分组**: 将相关的逻辑组织在一起\n2. **可组合函数**: 提取可复用的逻辑到自定义 hooks\n3. **类型安全**: 结合 TypeScript 获得更好的开发体验\n\n## 总结\n\nComposition API 为 Vue 3 带来了更强大的功能和更好的开发体验。虽然学习曲线可能稍陡，但掌握后将大大提升开发效率和代码质量。",
    "publishDate": "2024-01-15",
    "publishedAt": "2024-01-15",
    "updateDate": "2024-01-16",
    "updatedAt": "2024-01-16",
    "category": "前端开发",
    "tags": ["Vue.js", "JavaScript", "前端框架"],
    "readingTime": 8,
    "featured": true,
    "coverImage": "https://trae-api-sg.mchost.guru/api/ide/v1/text_to_image?prompt=Vue.js%20logo%20with%20modern%20code%20background%2C%20green%20theme&image_size=landscape_16_9"
  },
  {
    "id": "2",
    "title": "现代前端工程化实践指南",
    "slug": "modern-frontend-engineering-guide",
    "excerpt": "从构建工具到部署流程，全面介绍现代前端工程化的最佳实践，帮助团队建立高效的开发工作流。",
    "content": "# 现代前端工程化实践指南\n\n前端工程化是现代Web开发不可或缺的一部分。本文将从多个维度介绍如何建立完善的前端工程化体系。\n\n## 构建工具选择\n\n### Vite vs Webpack\n\n**Vite 的优势：**\n- 极快的冷启动\n- 热更新速度快\n- 开箱即用的 TypeScript 支持\n\n**Webpack 的优势：**\n- 生态成熟\n- 配置灵活\n- 插件丰富\n\n```javascript\n// vite.config.ts\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\n\nexport default defineConfig({\n  plugins: [vue()],\n  build: {\n    rollupOptions: {\n      output: {\n        manualChunks: {\n          vendor: ['vue', 'vue-router']\n        }\n      }\n    }\n  }\n})\n```\n\n## 代码质量保障\n\n### ESLint + Prettier\n\n统一的代码风格和质量检查：\n\n```json\n{\n  \"extends\": [\n    \"@vue/typescript/recommended\",\n    \"prettier\"\n  ],\n  \"rules\": {\n    \"@typescript-eslint/no-unused-vars\": \"error\",\n    \"vue/multi-word-component-names\": \"off\"\n  }\n}\n```\n\n### 自动化测试\n\n- 单元测试：Jest + Vue Test Utils\n- E2E测试：Cypress\n- 视觉回归测试：Percy\n\n## CI/CD 流程\n\n使用 GitHub Actions 实现自动化部署：\n\n```yaml\nname: Deploy\non:\n  push:\n    branches: [main]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Setup Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '18'\n      - name: Install dependencies\n        run: npm ci\n      - name: Build\n        run: npm run build\n      - name: Deploy\n        run: npm run deploy\n```\n\n## 性能优化\n\n1. **代码分割**: 使用动态导入实现路由级别的代码分割\n2. **资源优化**: 图片压缩、CDN加速\n3. **缓存策略**: 合理设置缓存头\n\n## 总结\n\n现代前端工程化需要综合考虑开发效率、代码质量、性能优化等多个方面。建立完善的工程化体系需要时间和实践，但带来的收益是巨大的。",
    "publishDate": "2024-01-10",
    "publishedAt": "2024-01-10",
    "category": "工程化",
    "tags": ["工程化", "构建工具", "CI/CD"],
    "readingTime": 12,
    "featured": true,
    "coverImage": "https://trae-api-sg.mchost.guru/api/ide/v1/text_to_image?prompt=modern%20development%20workflow%2C%20gears%20and%20code%2C%20blue%20theme&image_size=landscape_16_9"
  },
  {
    "id": "3",
    "title": "TypeScript 进阶技巧与实践",
    "slug": "typescript-advanced-tips",
    "excerpt": "探索 TypeScript 的高级特性，包括泛型、条件类型、映射类型等，提升代码的类型安全性和开发效率。",
    "content": "# TypeScript 进阶技巧与实践\n\nTypeScript 不仅仅是 JavaScript 的超集，它还提供了强大的类型系统。掌握这些进阶技巧将让你的代码更加健壮。\n\n## 泛型的高级用法\n\n### 条件类型\n\n```typescript\ntype ApiResponse<T> = T extends string \n  ? { message: T } \n  : { data: T }\n\ntype StringResponse = ApiResponse<string> // { message: string }\ntype DataResponse = ApiResponse<User> // { data: User }\n```\n\n### 映射类型\n\n```typescript\ntype Partial<T> = {\n  [P in keyof T]?: T[P]\n}\n\ntype Required<T> = {\n  [P in keyof T]-?: T[P]\n}\n```\n\n## 实用工具类型\n\n### Pick 和 Omit\n\n```typescript\ninterface User {\n  id: number\n  name: string\n  email: string\n  password: string\n}\n\ntype PublicUser = Pick<User, 'id' | 'name' | 'email'>\ntype CreateUser = Omit<User, 'id'>\n```\n\n### 自定义工具类型\n\n```typescript\ntype DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]\n}\n\ntype NonNullable<T> = T extends null | undefined ? never : T\n```\n\n## 装饰器模式\n\n```typescript\nfunction Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value\n  \n  descriptor.value = function (...args: any[]) {\n    console.log(`Calling ${propertyKey} with args:`, args)\n    return originalMethod.apply(this, args)\n  }\n}\n\nclass ApiService {\n  @Log\n  async fetchUser(id: number) {\n    // 实现逻辑\n  }\n}\n```\n\n## 类型守卫\n\n```typescript\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string'\n}\n\nfunction processValue(value: unknown) {\n  if (isString(value)) {\n    // 这里 value 的类型被缩窄为 string\n    console.log(value.toUpperCase())\n  }\n}\n```\n\n## 最佳实践\n\n1. **严格模式**: 启用 `strict` 模式获得最佳类型检查\n2. **类型优先**: 优先使用类型而不是接口\n3. **避免 any**: 尽量避免使用 `any` 类型\n4. **渐进式采用**: 在现有项目中逐步引入 TypeScript\n\n## 总结\n\nTypeScript 的类型系统非常强大，掌握这些进阶技巧能够显著提升代码质量和开发体验。持续学习和实践是掌握 TypeScript 的关键。",
    "publishDate": "2024-01-05",
    "publishedAt": "2024-01-05",
    "category": "编程语言",
    "tags": ["TypeScript", "类型系统", "JavaScript"],
    "readingTime": 10,
    "featured": false,
    "coverImage": "https://trae-api-sg.mchost.guru/api/ide/v1/text_to_image?prompt=TypeScript%20logo%20with%20code%20syntax%2C%20blue%20theme&image_size=landscape_16_9"
  },
  {
    "id": "4",
    "title": "React Hooks 最佳实践",
    "slug": "react-hooks-best-practices",
    "excerpt": "深入了解 React Hooks 的使用技巧和最佳实践，避免常见陷阱，编写更高效的 React 组件。",
    "content": "# React Hooks 最佳实践\n\nReact Hooks 改变了我们编写 React 组件的方式。本文将分享一些实用的最佳实践。\n\n## 基础 Hooks\n\n### useState 优化\n\n```jsx\n// ❌ 避免在渲染过程中创建昂贵的初始状态\nconst [state, setState] = useState(expensiveComputation())\n\n// ✅ 使用惰性初始化\nconst [state, setState] = useState(() => expensiveComputation())\n```\n\n### useEffect 最佳实践\n\n```jsx\n// ✅ 正确的依赖数组\nuseEffect(() => {\n  fetchData(userId)\n}, [userId])\n\n// ✅ 清理副作用\nuseEffect(() => {\n  const timer = setInterval(() => {\n    // 定时器逻辑\n  }, 1000)\n  \n  return () => clearInterval(timer)\n}, [])\n```\n\n## 自定义 Hooks\n\n### 数据获取 Hook\n\n```jsx\nfunction useApi(url) {\n  const [data, setData] = useState(null)\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState(null)\n  \n  useEffect(() => {\n    let cancelled = false\n    \n    fetch(url)\n      .then(response => response.json())\n      .then(data => {\n        if (!cancelled) {\n          setData(data)\n          setLoading(false)\n        }\n      })\n      .catch(error => {\n        if (!cancelled) {\n          setError(error)\n          setLoading(false)\n        }\n      })\n    \n    return () => {\n      cancelled = true\n    }\n  }, [url])\n  \n  return { data, loading, error }\n}\n```\n\n### 本地存储 Hook\n\n```jsx\nfunction useLocalStorage(key, initialValue) {\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key)\n      return item ? JSON.parse(item) : initialValue\n    } catch (error) {\n      return initialValue\n    }\n  })\n  \n  const setValue = (value) => {\n    try {\n      setStoredValue(value)\n      window.localStorage.setItem(key, JSON.stringify(value))\n    } catch (error) {\n      console.error(error)\n    }\n  }\n  \n  return [storedValue, setValue]\n}\n```\n\n## 性能优化\n\n### useMemo 和 useCallback\n\n```jsx\nfunction ExpensiveComponent({ items, filter }) {\n  // ✅ 缓存昂贵的计算\n  const filteredItems = useMemo(() => {\n    return items.filter(item => item.category === filter)\n  }, [items, filter])\n  \n  // ✅ 缓存回调函数\n  const handleClick = useCallback((id) => {\n    // 处理点击\n  }, [])\n  \n  return (\n    <div>\n      {filteredItems.map(item => (\n        <Item key={item.id} item={item} onClick={handleClick} />\n      ))}\n    </div>\n  )\n}\n```\n\n## 常见陷阱\n\n1. **闭包陷阱**: 在 useEffect 中使用过期的状态值\n2. **无限循环**: 依赖数组设置不当导致的无限重渲染\n3. **内存泄漏**: 忘记清理副作用\n\n## 总结\n\nReact Hooks 提供了强大而灵活的状态管理和副作用处理能力。遵循最佳实践能够帮助我们编写更高效、更可维护的 React 应用。",
    "publishDate": "2023-12-28",
    "publishedAt": "2023-12-28",
    "category": "前端开发",
    "tags": ["React", "Hooks", "性能优化"],
    "readingTime": 9,
    "featured": false,
    "coverImage": "https://trae-api-sg.mchost.guru/api/ide/v1/text_to_image?prompt=React%20hooks%20concept%2C%20modern%20UI%20components%2C%20blue%20theme&image_size=landscape_16_9"
  },
  {
    "id": "5",
    "title": "CSS Grid 布局完全指南",
    "slug": "css-grid-complete-guide",
    "excerpt": "从基础概念到高级技巧，全面掌握 CSS Grid 布局系统，创建复杂而灵活的网页布局。",
    "content": "# CSS Grid 布局完全指南\n\nCSS Grid 是现代 CSS 中最强大的布局系统之一。本文将带你从零开始掌握 Grid 布局。\n\n## 基础概念\n\n### Grid 容器和项目\n\n```css\n.container {\n  display: grid;\n  grid-template-columns: 1fr 1fr 1fr;\n  grid-template-rows: 100px 200px;\n  gap: 20px;\n}\n```\n\n### 网格线和网格轨道\n\n```css\n.container {\n  display: grid;\n  grid-template-columns: [start] 1fr [middle] 1fr [end];\n  grid-template-rows: [header-start] 100px [header-end content-start] 1fr [content-end];\n}\n```\n\n## 项目定位\n\n### 基于线的定位\n\n```css\n.item {\n  grid-column-start: 1;\n  grid-column-end: 3;\n  grid-row-start: 1;\n  grid-row-end: 2;\n}\n\n/* 简写形式 */\n.item {\n  grid-column: 1 / 3;\n  grid-row: 1 / 2;\n}\n\n/* 更简洁的写法 */\n.item {\n  grid-area: 1 / 1 / 2 / 3;\n}\n```\n\n### 命名网格区域\n\n```css\n.container {\n  display: grid;\n  grid-template-areas:\n    \"header header header\"\n    \"sidebar content content\"\n    \"footer footer footer\";\n  grid-template-columns: 200px 1fr 1fr;\n  grid-template-rows: 80px 1fr 60px;\n}\n\n.header { grid-area: header; }\n.sidebar { grid-area: sidebar; }\n.content { grid-area: content; }\n.footer { grid-area: footer; }\n```\n\n## 响应式设计\n\n### 自适应列数\n\n```css\n.container {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n  gap: 20px;\n}\n```\n\n### 媒体查询结合\n\n```css\n.container {\n  display: grid;\n  grid-template-columns: 1fr;\n  gap: 20px;\n}\n\n@media (min-width: 768px) {\n  .container {\n    grid-template-columns: repeat(2, 1fr);\n  }\n}\n\n@media (min-width: 1024px) {\n  .container {\n    grid-template-columns: repeat(3, 1fr);\n  }\n}\n```\n\n## 高级技巧\n\n### 子网格 (Subgrid)\n\n```css\n.parent {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n}\n\n.child {\n  display: grid;\n  grid-column: 1 / 4;\n  grid-template-columns: subgrid;\n}\n```\n\n### 网格对齐\n\n```css\n.container {\n  display: grid;\n  justify-items: center; /* 水平对齐 */\n  align-items: center;   /* 垂直对齐 */\n  justify-content: space-between; /* 整个网格的水平对齐 */\n  align-content: space-around;    /* 整个网格的垂直对齐 */\n}\n```\n\n## 实际应用案例\n\n### 卡片布局\n\n```css\n.card-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));\n  gap: 24px;\n  padding: 24px;\n}\n\n.card {\n  background: white;\n  border-radius: 8px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n  overflow: hidden;\n}\n```\n\n### 圣杯布局\n\n```css\n.layout {\n  display: grid;\n  grid-template-areas:\n    \"header header header\"\n    \"nav main aside\"\n    \"footer footer footer\";\n  grid-template-columns: 200px 1fr 200px;\n  grid-template-rows: auto 1fr auto;\n  min-height: 100vh;\n}\n```\n\n## 浏览器支持\n\nCSS Grid 在现代浏览器中有很好的支持：\n- Chrome 57+\n- Firefox 52+\n- Safari 10.1+\n- Edge 16+\n\n## 总结\n\nCSS Grid 为我们提供了强大而灵活的布局能力。掌握 Grid 布局将让你能够轻松创建复杂的网页布局，提升开发效率和用户体验。",
    "publishDate": "2023-12-20",
    "publishedAt": "2023-12-20",
    "category": "CSS",
    "tags": ["CSS", "布局", "Grid"],
    "readingTime": 11,
    "featured": false,
    "coverImage": "https://trae-api-sg.mchost.guru/api/ide/v1/text_to_image?prompt=CSS%20grid%20layout%20visualization%2C%20geometric%20patterns%2C%20modern%20design&image_size=landscape_16_9"
  }
]